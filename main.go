package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"golang.org/x/tools/go/loader"
)

var (
	outputFile = flag.String("o", "", "write output to `file` (default standard output)")
	dstPath    = flag.String("dst", "", "set destination import `path` (default taken from current directory)")
	pkgName    = flag.String("pkg", "", "set destination package `name` (default taken from current directory)")
	prefix     = flag.String("prefix", "", "set bundled identifier prefix to `p` (default source package name + \"_\")")
	underscore = flag.Bool("underscore", false, "rewrite golang.org to golang_org in imports; temporary workaround for golang.org/issue/16333")

	importMap = map[string]string{}
)

func init() {
	flag.Var(flagFunc(addImportMap), "import", "rewrite import using `map`, of form old=new (can be repeated)")
}

func addImportMap(s string) {
	if strings.Count(s, "=") != 1 {
		log.Fatal("-import argument must be of the form old=new")
	}
	i := strings.Index(s, "=")
	old, new := s[:i], s[i+1:]
	if old == "" || new == "" {
		log.Fatal("-import argument must be of the form old=new; old and new must be non-empty")
	}
	importMap[old] = new
}

func usage() {
	fmt.Fprintf(os.Stderr, "Usage: goreuse [options] <src>\n")
	flag.PrintDefaults()
}

func main() {
	log.SetPrefix("goreuse: ")
	log.SetFlags(0)

	flag.Usage = usage
	flag.Parse()
	args := flag.Args()
	if len(args) != 1 {
		usage()
		os.Exit(2)
	}

	if *dstPath != "" {
		if *pkgName == "" {
			*pkgName = path.Base(*dstPath)
		}
	} else {
		wd, _ := os.Getwd()
		pkg, err := build.ImportDir(wd, 0)
		if err != nil {
			log.Fatalf("cannot find package in current directory: %v", err)
		}
		*dstPath = pkg.ImportPath
		if *pkgName == "" {
			*pkgName = pkg.Name
		}
	}

	// changed
	before()

	code, err := bundle(args[0], *dstPath, *pkgName, *prefix)
	if err != nil {
		log.Fatal(err)
	}
	if *outputFile != "" {
		err := ioutil.WriteFile(*outputFile, code, 0666)
		if err != nil {
			log.Fatal(err)
		}

		// changed
		after()
	} else {
		_, err := os.Stdout.Write(code)
		if err != nil {
			log.Fatal(err)
		}
	}
}

// isStandardImportPath is copied from cmd/go in the standard library.
func isStandardImportPath(path string) bool {
	i := strings.Index(path, "/")
	if i < 0 {
		i = len(path)
	}
	elem := path[:i]
	return !strings.Contains(elem, ".")
}

var ctxt = &build.Default

func bundle(src, dst, dstpkg, prefix string) ([]byte, error) {
	// Load the initial package.
	conf := loader.Config{ParserMode: parser.ParseComments, Build: ctxt}
	conf.TypeCheckFuncBodies = func(p string) bool { return p == src }
	conf.Import(src)

	lprog, err := conf.Load()
	if err != nil {
		return nil, err
	}

	// Because there was a single Import call and Load succeeded,
	// InitialPackages is guaranteed to hold the sole requested package.
	info := lprog.InitialPackages()[0]
	if prefix == "" {
		pkgName := info.Files[0].Name.Name
		prefix = pkgName + "_"
	}

	objsToUpdate := make(map[types.Object]bool)
	var rename func(from types.Object)
	rename = func(from types.Object) {
		if !objsToUpdate[from] {
			objsToUpdate[from] = true

			// Renaming a type that is used as an embedded field
			// requires renaming the field too. e.g.
			// 	type T int // if we rename this to U..
			// 	var s struct {T}
			// 	print(s.T) // ...this must change too
			if _, ok := from.(*types.TypeName); ok {
				for id, obj := range info.Uses {
					if obj == from {
						if field := info.Defs[id]; field != nil {
							rename(field)
						}
					}
				}
			}
		}
	}

	// Rename each package-level object.
	scope := info.Pkg.Scope()
	for _, name := range scope.Names() {
		rename(scope.Lookup(name))
	}

	var out bytes.Buffer

	fmt.Fprintf(&out, "// Code generated by github.com/dc0d/goreuse. DO NOT EDIT.\n")
	if *outputFile != "" {
		fmt.Fprintf(&out, "//go:generate goreuse %s\n", strings.Join(os.Args[1:], " "))
	} else {
		fmt.Fprintf(&out, "//   $ goreuse %s\n", strings.Join(os.Args[1:], " "))
	}
	fmt.Fprintf(&out, "\n")

	// Concatenate package comments from all files...
	for _, f := range info.Files {
		if doc := f.Doc.Text(); strings.TrimSpace(doc) != "" {
			for _, line := range strings.Split(doc, "\n") {
				fmt.Fprintf(&out, "// %s\n", line)
			}
		}
	}
	// ...but don't let them become the actual package comment.
	fmt.Fprintln(&out)

	fmt.Fprintf(&out, "package %s\n\n", dstpkg)

	// BUG(adonovan,shurcooL): bundle may generate incorrect code
	// due to shadowing between identifiers and imported package names.
	//
	// The generated code will either fail to compile or
	// (unlikely) compile successfully but have different behavior
	// than the original package. The risk of this happening is higher
	// when the original package has renamed imports (they're typically
	// renamed in order to resolve a shadow inside that particular .go file).

	// TODO(adonovan,shurcooL):
	// - detect shadowing issues, and either return error or resolve them
	// - preserve comments from the original import declarations.

	// pkgStd and pkgExt are sets of printed import specs. This is done
	// to deduplicate instances of the same import name and path.
	var pkgStd = make(map[string]bool)
	var pkgExt = make(map[string]bool)
	for _, f := range info.Files {
		for _, imp := range f.Imports {
			path, err := strconv.Unquote(imp.Path.Value)
			if err != nil {
				log.Fatalf("invalid import path string: %v", err) // Shouldn't happen here since conf.Load succeeded.
			}
			if path == dst {
				continue
			}
			if newPath, ok := importMap[path]; ok {
				path = newPath
			}

			var name string
			if imp.Name != nil {
				name = imp.Name.Name
			}
			spec := fmt.Sprintf("%s %q", name, path)
			if isStandardImportPath(path) {
				pkgStd[spec] = true
			} else {
				if *underscore {
					spec = strings.Replace(spec, "golang.org/", "golang_org/", 1)
				}
				pkgExt[spec] = true
			}
		}
	}

	// Print a single declaration that imports all necessary packages.
	fmt.Fprintln(&out, "import (")
	for p := range pkgStd {
		fmt.Fprintf(&out, "\t%s\n", p)
	}
	if len(pkgExt) > 0 {
		fmt.Fprintln(&out)
	}
	for p := range pkgExt {
		fmt.Fprintf(&out, "\t%s\n", p)
	}
	fmt.Fprint(&out, ")\n\n")

	// Modify and print each file.
	for _, f := range info.Files {
		// Update renamed identifiers.
		for id, obj := range info.Defs {
			if objsToUpdate[obj] {
				// changed
				if nn, ok := oldnewSymbolRename[id.Name]; ok {
					mark(obj, nn.newName, id.Name)
					id.Name = nn.newName
				} else {
					mark(obj, prefix+obj.Name(), id.Name)
					id.Name = prefix + obj.Name()
				}

				// origin
				// id.Name = prefix + obj.Name()
			}
		}
		for id, obj := range info.Uses {
			if objsToUpdate[obj] {
				// changed
				if nn, ok := oldnewSymbolRename[id.Name]; ok {
					mark(obj, nn.newName, id.Name)
					id.Name = nn.newName
				} else {
					mark(obj, prefix+obj.Name(), id.Name)
					id.Name = prefix + obj.Name()
				}
				// origin
				// id.Name = prefix + obj.Name()
			}
		}

		// For each qualified identifier that refers to the
		// destination package, remove the qualifier.
		// The "" strings are removed in postprocessing.
		ast.Inspect(f, func(n ast.Node) bool {
			if sel, ok := n.(*ast.SelectorExpr); ok {
				if id, ok := sel.X.(*ast.Ident); ok {
					if obj, ok := info.Uses[id].(*types.PkgName); ok {
						if obj.Imported().Path() == dst {
							id.Name = "@@@"
						}
					}
				}
			}
			return true
		})

		last := f.Package
		if len(f.Imports) > 0 {
			imp := f.Imports[len(f.Imports)-1]
			last = imp.End()
			if imp.Comment != nil {
				if e := imp.Comment.End(); e > last {
					last = e
				}
			}
		}

		// Pretty-print package-level declarations.
		// but no package or import declarations.
		var buf bytes.Buffer
		for _, decl := range f.Decls {
			if decl, ok := decl.(*ast.GenDecl); ok && decl.Tok == token.IMPORT {
				continue
			}

			beg, end := sourceRange(decl)

			printComments(&out, f.Comments, last, beg)

			buf.Reset()
			format.Node(&buf, lprog.Fset, &printer.CommentedNode{Node: decl, Comments: f.Comments})
			// Remove each "" in the output.
			// TODO(adonovan): not hygienic.
			out.Write(bytes.Replace(buf.Bytes(), []byte(""), nil, -1))

			last = printSameLineComment(&out, f.Comments, lprog.Fset, end)

			out.WriteString("\n\n")
		}

		printLastComments(&out, f.Comments, last)
	}

	// Now format the entire thing.
	result, err := format.Source(out.Bytes())
	if err != nil {
		log.Fatalf("formatting failed: %v", err)
	}

	return result, nil
}

// sourceRange returns the [beg, end) interval of source code
// belonging to decl (incl. associated comments).
func sourceRange(decl ast.Decl) (beg, end token.Pos) {
	beg = decl.Pos()
	end = decl.End()

	var doc, com *ast.CommentGroup

	switch d := decl.(type) {
	case *ast.GenDecl:
		doc = d.Doc
		if len(d.Specs) > 0 {
			switch spec := d.Specs[len(d.Specs)-1].(type) {
			case *ast.ValueSpec:
				com = spec.Comment
			case *ast.TypeSpec:
				com = spec.Comment
			}
		}
	case *ast.FuncDecl:
		doc = d.Doc
	}

	if doc != nil {
		beg = doc.Pos()
	}
	if com != nil && com.End() > end {
		end = com.End()
	}

	return beg, end
}

func printComments(out *bytes.Buffer, comments []*ast.CommentGroup, pos, end token.Pos) {
	for _, cg := range comments {
		if pos <= cg.Pos() && cg.Pos() < end {
			for _, c := range cg.List {
				fmt.Fprintln(out, c.Text)
			}
			fmt.Fprintln(out)
		}
	}
}

const infinity = 1 << 30

func printLastComments(out *bytes.Buffer, comments []*ast.CommentGroup, pos token.Pos) {
	printComments(out, comments, pos, infinity)
}

func printSameLineComment(out *bytes.Buffer, comments []*ast.CommentGroup, fset *token.FileSet, pos token.Pos) token.Pos {
	tf := fset.File(pos)
	for _, cg := range comments {
		if pos <= cg.Pos() && tf.Line(cg.Pos()) == tf.Line(pos) {
			for _, c := range cg.List {
				fmt.Fprintln(out, c.Text)
			}
			return cg.End()
		}
	}
	return pos
}

type flagFunc func(string)

func (f flagFunc) Set(s string) error {
	f(s)
	return nil
}

func (f flagFunc) String() string { return "" }

//-----------------------------------------------------------------------------

func before() {
	if len(oldnewSymbolRename) == 0 {
		return
	}
	if info, err := os.Stat(*outputFile); err != nil || info.IsDir() {
		return
	}
	fset := token.NewFileSet()
	fast, err := parser.ParseFile(
		fset,
		*outputFile,
		nil,
		parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}
	content, err := ioutil.ReadFile(*outputFile)
	if err != nil {
		log.Fatal(err)
	}
	_before.content = content
	_before.set = fset
	_before.ast = fast
}

func after() {
	if info, err := os.Stat(*outputFile); err != nil || info.IsDir() {
		return
	}
	fset := token.NewFileSet()
	fast, err := parser.ParseFile(
		fset,
		*outputFile,
		nil,
		parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}
	content, err := ioutil.ReadFile(*outputFile)
	if err != nil {
		log.Fatal(err)
	}
	_after.content = content
	_after.set = fset
	_after.ast = fast

	filteredBefore := pickSymbols(_before.set, _before.ast, true)
	filteredAfter := pickSymbols(_after.set, _after.ast, true)

	var defs sortableDefs
	for kb, vb := range filteredBefore {
		va, ok := filteredAfter[kb]
		if !ok {
			continue
		}
		if !vb.rename.preserve {
			continue
		}
		epb := vb.endposer()
		epa := va.endposer()
		if epa == nil || epb == nil {
			continue
		}
		var d definf
		sa, ea := offsets(_after.set, epa)
		d.afterPos = [2]int{sa, ea}
		sb, eb := offsets(_before.set, epb)
		d.beforePos = [2]int{sb, eb}
		d.beforeContent = _before.content[sb:eb]
		defs = append(defs, d)
	}
	if len(defs) == 0 {
		return
	}
	sort.Sort(defs)

	lastPos := 0
	finaldst := &bytes.Buffer{}
	for _, vk := range defs {
		finaldst.Write(_after.content[lastPos:vk.afterPos[0]])
		finaldst.Write(vk.beforeContent)
		lastPos = vk.afterPos[1]
	}
	if lastPos > 0 {
		finaldst.Write(_after.content[lastPos:])
	}
	if err := ioutil.WriteFile(*outputFile, finaldst.Bytes(), 777); err != nil {
		log.Fatal(err)
		os.Exit(1)
	}
}

type definf struct {
	beforePos     [2]int
	beforeContent []byte
	afterPos      [2]int
}

type sortableDefs []definf

func (e sortableDefs) Len() int           { return len(e) }
func (e sortableDefs) Swap(i, j int)      { e[i], e[j] = e[j], e[i] }
func (e sortableDefs) Less(i, j int) bool { return e[i].beforePos[0] < e[j].beforePos[0] }

func offsets(set *token.FileSet, v endposer) (start, end int) {
	start = int(set.Position(v.Pos()).Offset)
	end = int(set.Position(v.End()).Offset)
	return
}

func pickSymbols(
	fset *token.FileSet,
	fast *ast.File,
	pickNew ...bool) map[string]*pickedNode {
	filtered := make(map[string]*pickedNode)
	if fset == nil || fast == nil {
		return filtered
	}
	var _pickNew bool
	if len(pickNew) > 0 && pickNew[0] {
		_pickNew = true
	}
	pickName := func(name string) (rename, string, bool) {
		var (
			rn rename
			ok bool
		)
		var dic map[string]rename
		if _pickNew {
			dic = newoldSymbolRename
		} else {
			dic = oldnewSymbolRename
		}
		rn, ok = dic[name]
		return rn, name, ok
	}
	for _, vdecl := range fast.Decls {
		switch x := vdecl.(type) {
		case *ast.FuncDecl:
			rn, name, ok := pickName(x.Name.Name)
			if ok {
				filtered[name] = &pickedNode{
					rename:   rn,
					funcDecl: x,
				}
			}
		case *ast.GenDecl:
			for _, vspec := range x.Specs {
				switch xspec := vspec.(type) {
				case *ast.TypeSpec:
					rn, name, ok := pickName(xspec.Name.Name)
					if ok {
						filtered[name] = &pickedNode{
							rename:   rn,
							typeSpec: xspec,
						}
					}
				case *ast.ValueSpec:
					for kval, vval := range xspec.Names {
						rn, name, ok := pickName(vval.Name)
						if ok {
							v := pickedNode{
								rename: rn,
							}
							v.valueSpec = xspec
							v.valueIndex = kval
							filtered[name] = &v
						}
					}
				default:
				}
			}
		default:
		}
	}
	return filtered
}

type pickedNode struct {
	rename     rename
	funcDecl   *ast.FuncDecl
	typeSpec   *ast.TypeSpec
	valueSpec  *ast.ValueSpec
	valueIndex int
}

func (pn *pickedNode) endposer() endposer {
	var item endposer
	switch {
	case pn.funcDecl != nil:
		item = pn.funcDecl
	case pn.typeSpec != nil:
		item = pn.typeSpec
	case pn.valueSpec != nil:
		item = pn.valueSpec.Values[pn.valueIndex]
	}
	return item
}

type endposer interface {
	Pos() token.Pos
	End() token.Pos
}

func mark(obj types.Object, n, o string) {
	if _, ok := oldnew[obj]; ok {
		return
	}
	oldnew[obj] = [2]string{n, o}
}

var (
	oldnew  = map[types.Object][2]string{}
	_before struct {
		content []byte
		set     *token.FileSet
		ast     *ast.File
	}
	_after struct {
		content []byte
		set     *token.FileSet
		ast     *ast.File
	}
)

//-----------------------------------------------------------------------------

var (
	oldnewSymbolRename = map[string]rename{}
	newoldSymbolRename = map[string]rename{}
)

type rename struct {
	newName, oldName string
	preserve         bool
}

func (rn rename) String() string {
	if len(rn.newName) == 0 ||
		len(rn.oldName) == 0 {
		return "N/A"
	}
	var ps string
	if rn.preserve {
		ps = "+"
	}
	return rn.newName + ps + "=" + rn.oldName
}

func addSymbolRename(s string) {
	var rename rename
	rgx := regexp.MustCompile("^(?P<new>\\w+)(?P<preserve>\\+)*=(?P<old>\\w+)$")
	nl := rgx.SubexpNames()
	rr := rgx.FindAllStringSubmatch(s, -1)
	if len(rr) == 0 {
		log.Fatalf("invalid pair: %v", s)
	}
	parts := make(map[string]string)
	for k, v := range rr[0] {
		parts[nl[k]] = v
	}
	rename.newName = parts["new"]
	rename.oldName = parts["old"]
	if parts["preserve"] == "+" {
		rename.preserve = true
	}
	oldnewSymbolRename[rename.oldName] = rename
	newoldSymbolRename[rename.newName] = rename
}

func init() {
	flag.Var(flagFunc(addSymbolRename), "rn", "needs -o, rename identifier new=old or new+=old to preserve the modifications (can be repeated)")
}

//-----------------------------------------------------------------------------
